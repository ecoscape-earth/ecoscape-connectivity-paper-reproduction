# Bird Mapping Project

The code in this repository generates habitat and terrrain information for birds, 
models habitat quality and connectivity, 
and evaluates the resulting habitat quality using eBird data. 

## Contributors (alphabetically)

* Coen Adler
* Luca de Alfaro
* Artie Nazarov
* Natalia Ocampo-PeÃ±uela
* Tyler Sorensen
* Jasmine Tai
* Natalie Valett

## Code Flow 

Generally, before running a notebook, make your own copy of it, so as not to conflict with anybody else's code. 

Below, we describe each step of code, with in parentheses a nickname for the step. 
For each step, we say depend(x, y) to mean that it depends on steps x, y being completed previously. 

## Setup and Input Files

Before one starts, one needs to take a look at `ecoscape_`.  
That file describes the location of every input and output. 
There: 

* A bird name is its English name, such as "Acorn Woodpecker". 
* A bird nickname is its eBird API nickname, such as "acowoo". 

The input files are the following, where `{bird}` is the bird nickname. All of these file names are relative to a root directory, which can be specified in the code: 

* `Data/CA/Terrain/terrain.tif` is the terrain description for California, at 300m resolution. 
* `Data/CA/{bird}/habitat.tif` is the habitat raster for each bird (this can be regenerated with the Generating Habitats step below). 
* `Data/CA/{bird}/resistance.csv` is the raw terrain resistance for each bird. This is obtained from IUCN data, and will be refined below. 

In addition to these, there are files that are generated by our code.  These contain parameter values in the filenames, often; these are: 

* `run_name` is generally "Default". 
* `num_spreads` is the number of hops a bird can do during dispersal. 
* `hop_distance` is the length of a bird hop, measured in squares. Each square has an edge of 300m, so a hop distance of 2 corresponds to 600m. 
* `num_simulations` is the number of simulations performed for the spread process; a typical value is several hundreds. 

The main files generated are:   

* `Data/CA/{bird}/terrain_hist.json` and `Data/CA/{bird}/terrain_hist.csv` are histogram of bird sightings according to terrain type.  They are used to refine the terrain resistance, and are generated by one of the steps below.  The two files contain the same information, in different formats. 
* `Data/CA/{bird}/Output/{run_name}/repopulation_spreads_{num_spreads}_hop_{hop_distance}_sims_{num_simulations}.tif` contains the output of the connectivity, in geotiff format.  These are values between 0 and 1, multiplied by 255 and encoded as integers. 
* `Data/CA/{bird}/Output/{run_name}/gradient_spreads_{num_spreads}_hop_{hop_distance}_sims_{num_simulations}.tif` contains the gradient computed for the repopulation, in geotiff format.  For a repopulation value of $r$, we output $20 log_10(1 + r)$, clipped between 0 and 255. 
* `Data/CA/{bird}/Observations/CA_all_len_{l}_2012-01-01-2018-12-31_20000.csv` contain data on all bird observations in checklists of length at least `l` in a given date range, limited to 20,000 observation locations if necessary.  Generally, for the given date range, there were a few more than 18,000 observation locations (technically, squares; see `ebird_data/README.md`).
* `Data/CA/{bird}/Output/{run_name}/obs_{num_spreads}_hop_{hop_distance}_sims_{num_simulations}.csv` is a Pandas dataframe containing data with the repopulation value, and sightings, of a bird at the various locations.  These dataframes are read by the code that generates the graphs. 
 
## Generating Habitats 

> Step (habitat), depends(). 

The code for generating habitats is in the `habitat_generation` directory; please see the 
[README](habitat_generation/README.md) file there. 

## Generating the transmissibility of birds in terrain

> Step (transmission), depends(habitat). 

This step is necessary because the values of terrain resistance we obtain
from IUCN data are for a terrain classification that is not closely tailored 
to California (or to the terrain one might be studying). 
Hence, we lower the terrain resistance of terrain types in which
many birds have been sighted. 

This is done in two steps.

In the first step, we measure the number of sightings in each type of terrain. 
This is done in the `TerrainHistograms.ipynb` notebook. 
The notebook needs access to the databases generated from ebird data. 

The second step consists in using the sightings information to refine the resistance. 
This is done in the notebook `RefineResistanceFromEbird.ipynb` 
If you change the explonent used for the terrain transmission refinement, namely, 
the `merge_exponent` in `merge_transmission_forest_birds(resistance_d, observation_d, merge_exponent)`, you need only rerun this last step, which is quite fast.
Of course, you then need to re-run the repopulation. 

### Run the repopulation

Step (repopulation), depends(transmission). 

* Upload to colab the notebook `Connectivity.ipynb`
* Change `IS_LOCAL = False`
* Change `DO_RUN = True`
* Run the notebook (you only need to run the run part)

You need to choose which birds to process, and with what parameters. 
If you have a GPU you can also run this step locally, but running the setp 
without a GPU will be rather slow.   

### Prepare the observation data for the validation

Step (prepare_validation), depends(habitat). 

Run the notebook `GenerateValidationData.ipynb`

You need to decide which birds to process, and which combination of ebird walked distance, min checklists per square, whether to use small (1Km) or big (10Km) squares, etc. 

For the paper, we run it with the following parameters:

```
max_distances = [2]
date_range = ("2012-01-01", "2018-12-31")
breeding = True
state = "US-CA"
num_sample_squares = 20000 # Sampling number for the squares. 
```

### Generates the validation dataframes

Step (validation) depends(prepare_validation, repopulation).

Use the notebook `Validation.ipynb`.  
This takes a while to run, as it needs to read all the various terrains, and 
write all the results. 

### Display the validation results.

Step (validation_results) depends(validation). 

Use the notebook `DisplayValidationResults.ipynb`.  This is quite fast, and allows
for tuning the output figures and data to one's desires. 


